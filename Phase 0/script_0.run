option reset_initial_guesses 0;  # Maintain current variable values as initial guess for next `solve` command
option cplex_options "time = 1800";
option cplex_options 'integrality=1e-12'; # Avoids rounding of variables with values bigger than 10^-12 to integer during B&B

#Time counter
param start_time;
param end_time;
param total_time;

# --------------------------------------------------------------------------------------------------------
# DEFINING ECONOMIC PARAMETERS
# --------------------------------------------------------------------------------------------------------
let comp_A:= 0.3*B_bar;              # Compensation for availability
let comp_U:= 1*B_bar;                # Compensation for use
let commission:= 0.5;                # Commission

# --------------------------------------------------------------------------------------------------------
# COMPUTE INITIAL FEASIBLE SOLUTION
# --------------------------------------------------------------------------------------------------------
let start_time:= time();

### Solve KKT formulation with no complementarities ###
# Constraint (2) in Mixed Integer Formulation
problem KKT_no_complementarity: profit_aggregator,
								charged, discharged, e_A, x, y, e_P, lambda, mu, u,
								sell, buy, aggregator_fairness, ESS_max_cap, update_e_A, initiate_e_A,
								buy_needed, buy_limit, sell_limit, max_cap, update_e_P, initiate_e_P, stat_x, stat_x_T, stat_y, stat_y_T, stat_e, stat_e_T;

print "BEGIN KKT WITH NO COMPLEMENTARITIES";
solve KKT_no_complementarity;
if (solve_result_num > 99) then {
		print "INFEASIBLE TERMINATION KKT WITHOUT COMPLEMENTARITIES";
		display solve_result;
		quit;
		};
print "END KKT WITH NO COMPLEMENTARITIES";

### Fix leader's decision variables ###
fix {i in I, t in T} e_A[i,t];
fix {i in I, t in T} charged[i,t];
fix {i in I, t in T} discharged[i,t];

### Solve Lower levels ###
problem lower_level{i in I}: prosumer_cost[i],
					 		 {t in T}x[i,t], {t in T}y[i,t], {t in T}e_P[i,t],
							 {t in T}buy_needed[i,t], {t in T}buy_limit[i,t], {t in T}sell_limit[i,t], {t in T}max_cap[i,t], {t in T:t>1}update_e_P[i,t], {t in T:t=1}initiate_e_P[i,t], {t in T}x_pos[i,t], {t in T}y_pos[i,t], {t in T}e_pos[i,t];
option presolve 0;

for {i in I}{
	print "BEGIN LOWER LEVEL", sprintf("%u", i);
	solve lower_level[i];
	print "END LOWER LEVEL", sprintf("%u", i);
	# Feasibility Check
	if (solve_result_num > 99) then {
		print "INFEASIBLE TERMINATION OF LOWER LEVEL",i;
		display solve_result;
		quit;
		};
	};

#option presolve 1;

# Updating dual variables values
#option presolve 0;
let {i in I, t in T} lambda[1,i,t]:= -buy_needed[i,t];
let {i in I, t in T} lambda[2,i,t]:= buy_limit[i,t];
let {i in I, t in T} lambda[3,i,t]:= sell_limit[i,t];
let {i in I, t in T} lambda[4,i,t]:= max_cap[i,t];
let {i in I, t in T} lambda[5,i,t]:= -x_pos[i,t];
let {i in I, t in T} lambda[6,i,t]:= -y_pos[i,t];
let {i in I, t in T} lambda[7,i,t]:= -e_pos[i,t];
let {i in I, t in T: t=1} mu[i,t]:= initiate_e_P[i,t];
let {i in I, t in T: t>1} mu[i,t]:= update_e_P[i,t];
option presolve 1;

### Unfix leader's decision variables ###
unfix {i in I, t in T} e_A[i,t];
unfix {i in I, t in T} charged[i,t];
unfix {i in I, t in T} discharged[i,t];


let end_time:= time();
let total_time:= end_time-start_time;

# --------------------------------------------------------------------------------------------------------
# PRINTING OUTPUT
# --------------------------------------------------------------------------------------------------------
print "BEGIN OUTPUT DATA";

#----Data Model Parameters----
print "param comp_A :=", sprintf("%.6f" & ";\n",comp_A);
print "param comp_U :=", sprintf("%.6f" & ";\n",comp_U);
print "param commission :=", sprintf("%.3f" & ";\n",commission);

print "param n :=", sprintf("%u" & ";\n",n);
print "param t_max :=", sprintf("%u" & ";\n",t_max);
print "param S_ini :=", {i in I} sprintf("%u %.3f" & (if i = n then ";\n" else "\n"), i, S_ini[i]);
print "param S_max :=", {i in I} sprintf("%u %d" & (if i = n then ";\n" else "\n"), i, S_max[i]);
print "param price_W :=", {t in T} sprintf("%u %.3f" & (if t = t_max then ";\n" else "\n"), t, price_W[t]);
print "param price_R :=", {t in T} sprintf("%u %.3f" & (if t = t_max then ";\n" else "\n"), t, price_R[t]);
print "param B :=", {t in T} sprintf("%u %.4f" & (if t = t_max then ";\n" else "\n"), t, B[t]) ;
print "param G :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.3f",G[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.3f",G[i,t])&";\n" 
																   else sprintf("%.3f",G[i,t])&"\n")
												  else " "&sprintf("%.3f",G[i,t])));
print "param D :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.3f",D[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.3f",D[i,t])&";\n" 
																   else sprintf("%.3f",D[i,t])&"\n") 
												  else " "&sprintf("%.3f",D[i,t])));
print "param niu :=", sprintf("%.2f" & ";\n",niu);

#----Data for Initial solution----
# Leader variables
print "param charged_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",charged[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",charged[i,t])&";\n" 
																   else sprintf("%.4f",charged[i,t])&"\n") 
												  else " "&sprintf("%.4f",charged[i,t])));

print "param discharged_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",discharged[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",discharged[i,t])&";\n" 
																   else sprintf("%.4f",discharged[i,t])&"\n") 
												  else " "&sprintf("%.4f",discharged[i,t])));
print "param e_A_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",e_A[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",e_A[i,t])&";\n" 
																   else sprintf("%.4f",e_A[i,t])&"\n") 
												  else " "&sprintf("%.4f",e_A[i,t])));

# Follower variables
print "param x_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",x[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",x[i,t])&";\n" 
																   else sprintf("%.4f",x[i,t])&"\n") 
												  else " "&sprintf("%.4f",x[i,t])));
print "param y_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",y[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",y[i,t])&";\n" 
																   else sprintf("%.4f",y[i,t])&"\n") 
												  else " "&sprintf("%.4f",y[i,t])));
print "param e_P_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",e_P[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",e_P[i,t])&";\n" 
																   else sprintf("%.4f",e_P[i,t])&"\n") 
												  else " "&sprintf("%.4f",e_P[i,t])));

# Auxiliary variables
print "param mu_sol :", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
					{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",mu[i,t]) 
											else (if t=t_max then (if i=n then sprintf("%.4f",mu[i,t])&";\n" 
																   else sprintf("%.4f",mu[i,t])&"\n") 
												  else " "&sprintf("%.4f",mu[i,t])));

print "param lambda_sol :=";
for{c in C}{
	if c < 7 then 
		print "[",sprintf("%u",c),",*,*]:", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
							{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",lambda[c,i,t]) 
													else (if t=t_max then (sprintf("%.4f",lambda[c,i,t])&"\n") 
														  else " "&sprintf("%.4f",lambda[c,i,t])));
	else
		print "[",sprintf("%u",c),",*,*]:", {t in T} sprintf("%u" & (if t=t_max then ":=\n" else " "), t),
							{i in I, t in T} sprintf(if t=1 then i&" "&sprintf("%.4f",lambda[c,i,t]) 
													else (if t=t_max then (if i=n then sprintf("%.4f",lambda[c,i,t])&";\n" 
																		   else sprintf("%.4f",lambda[c,i,t])&"\n") 
														  else " "&sprintf("%.4f",lambda[c,i,t]))); };


# Data for computational experiment
print "param time_phase_0 :=", sprintf("%.6f" & ";\n",total_time);

print "END OUTPUT DATA";
